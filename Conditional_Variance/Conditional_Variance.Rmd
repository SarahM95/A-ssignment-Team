---
title: "Estimating the conditional variance by local linear regression"
author: "Gregoire Gasparini, Aurora Hofman, Sarah Musiol, Beatriu Tort"
date: "17 de marzo de 2020"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Aircraft data
```{r}
library(sm)

data(aircraft)
help(aircraft)
lgPower <- log(aircraft$Power)
lgSpan <- log(aircraft$Span)
lgLength <- log(aircraft$Length)
lgWeight <- log(aircraft$Weight)
lgSpeed <- log(aircraft$Speed)
lgRange <- log(aircraft$Range)
Yr <- aircraft$Yr
```


## Estimating the conditional variance

### First, use the function loc.pol.reg that you can find in ATENEA and choose all the bandwidth values you need by leave-one-out cross-validation (you have not to program it again! Just look for the right function in the *.Rmd files you can find in ATENEA)

```{r}
source("locpolreg.R")
```

K Fold cross validation for leave-one-out cross validation from ATENEA:

```{r}
k.fold.cv <- function(x,y,k=n,h=range(x)/10,p=1,type.kernel="normal"){
  n <- length(x)
  Ik <- floor((0:(n-1))/(n/k))+1
  ssr <- 0
  for (i in (1:k)){
    y.i <- y[Ik==i]
    aux <- locpolreg(x[Ik!=i],y[Ik!=i],h=h,p=p,tg=x[Ik==i],
                     type.kernel=type.kernel, doing.plot=FALSE)
    ssr <- ssr + sum((y.i-aux$mtgr)^2)
  }
  k.cv <- ssr/n
  return(k.cv)
}

h.k.fold.cv <- function(x,y,h.v = exp(seq(log(diff(range(x))/20),
                                          log(diff(range(x))/4),l=10)), 
                        k=n,p=1,type.kernel="normal"){
  n <- length(x)
  perm <- sample(1:n)
  xperm <- x[perm]
  yperm <- y[perm]
  
  k.cv <- h.v*0
  for (i in (1:length(h.v))){
    h <- h.v[i]
    k.cv[i] <- k.fold.cv(x=xperm,y=yperm,k=k,h=h,p=p,
                         type.kernel=type.kernel)
  }
  return(list(k=k,h.v=h.v,k.cv=k.cv))
}

bandwidth <- h.k.fold.cv(Yr, lgWeight) #consider if we need to use a different vector for h.v

bandwidth

```

Fitting the nonparametric regression to data (x,y) where $x$ is the $Yr$ and $y$ is the $lgWeigth$

```{r}
h_opt<- which.min(bandwidth$k.cv)

reg <- locpolreg(x=Yr, y=lgWeight, h=h_opt) 

mx <- reg$mtgr

z1 <- log((lgWeight-mx)^2) #Y- m(x)

```

Transform estimated residuals

```{r}
h_z <- h.k.fold.cv(Yr, z1) 
h_z_opt <- which.min(h_z$k.cv)

q <- locpolreg(Yr, z1, h=h_z_opt)

sigma2 <- exp(q$mtgr)
```

Draw a graphic of $\epsilon^2_i$ against $x_i$ and superimpose the estimated function $\sigma^2(x)$. Lastly draw the function $m(x)$ and superimpose the bands $$m(x) \pm 1.96\sigma(x)$$.

```{r}
e <- exp(z1)

banda <- 1.96*sqrt(sigma2)

data <- data.frame(Yr, lgWeight, mx, banda)

fp <- ggplot(data, aes(Yr, e)) + geom_point() + geom_line(aes(Yr, sigma2))
fp

mx_plot <- ggplot(data, aes(Yr, mx)) + geom_line() + geom_line(data = data, aes(Yr, mx+ banda), colour = 'red', linetype = "dashed")+ geom_line(data = data, aes(Yr, mx- banda), colour = 'red', linetype = "dashed") #+ geom_point(data = data, aes(Yr, lgWeight))
mx_plot

```


### Second, use the function sm.regression from library sm and choose all the bandwidth values you need by direct plug-in (use the function dpill from the same library KernSmooth).

```{r}
library(KernSmooth)
library(sm)

```

Just a test of the func with h arbritrary chosen

```{r}

#eval_points <- seq(6,13, length= 500)
sm.regression(y=lgWeight,x=Yr,h=.3, eval.points = Yr)#, eval.points = eval_points)
#sm.regression(x=lgWeight,y=Yr,h=.3)
#sm.options(eval.grid =TRUE)
#sm.regression(y=lgWeight,x=Yr,h=.3)

```

```{r}
h.dpill <- dpill(y=lgWeight,x=Yr,gridsize=101,
                 range.x=range(Yr))

print(h.dpill)
```
```{r}
fit_sm<- sm.regression(y=lgWeight,x=Yr,h=h.dpill, eval.points = Yr)
```

```{r}
m_hat_sm <- fit_sm$estimate
```

Transform estimated residuals

```{r}
z2 <- log(fit_sm$se^2)

z2

```

Just used the eval points form sm. We should se if we can change them to beeing all the points of lgweights

```{r}


#h.dpill_q<- dpill(Yr, z2, gridsize = 101, range.x = range(Yr)) #it produces a Nan value!!!!!! I dont know why. Why do we need it??

h_q<- h.k.fold.cv(Yr, z2) 

h_q_opt_index<- which.min(h_q$k.cv)
h_q_opt <- h_q$h.v[h_q_opt_index]

q_hat_sm <- sm.regression(x = Yr, y = z2, h= h_q_opt, eval.points = Yr)


```

Estimate $\sigma^2$

```{r}
sigma_squared_sm <- exp(q_hat_sm$estimate)
```

```{r}
bands <- 1.96*sqrt(sigma_squared_sm)
```

```{r}
library(ggplot2)

df <- data.frame(Yr, fit_sm$estimate, bands)

g <- ggplot(df, aes(Yr, fit_sm$estimate)) + geom_line() + geom_line(data = df, aes(Yr, fit_sm$estimate+ bands), colour = 'red', linetype = "dashed")+ geom_line(data = df, aes(Yr, fit_sm$estimate- bands), colour = 'red', linetype = "dashed")
g
```

